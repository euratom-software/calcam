<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Examples &mdash; Calcam  documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="File Formats" href="dev_fileformats.html" />
    <link rel="prev" title="Camera Movement Correction" href="api_movement.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html">
            <img src="_static/logo.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                Version 2.13
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="intro_general.html">General Introduction to Calcam</a></li>
<li class="toctree-l1"><a class="reference internal" href="intro_install_setup.html">Getting Up &amp; Running</a></li>
<li class="toctree-l1"><a class="reference internal" href="intro_theory.html">Camera Calibration Theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="intro_conventions.html">Concepts &amp; Conventions</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">GUI App User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="gui_intro.html">Introduction &amp; Launcher</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui_settings.html">Calcam Settings</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui_cad_editor.html">CAD Model Definition Editor</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui_calib.html">Calibration by point fitting</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui_alignment_calib.html">Calibration by manual alignment</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui_virtual_calib.html">“Virtual” Calibrations</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui_image_analyser.html">Image Analyser</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui_viewer.html">3D Viewer</a></li>
<li class="toctree-l1"><a class="reference internal" href="gui_movement.html">Camera Movement Determination</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API User Guide</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="api_calib.html">The Calibration Class</a></li>
<li class="toctree-l1"><a class="reference internal" href="api_cadmodel.html">CAD Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="api_raycast.html">Ray Casting</a></li>
<li class="toctree-l1"><a class="reference internal" href="api_rendering.html">Rendering Images</a></li>
<li class="toctree-l1"><a class="reference internal" href="api_geom_matrix.html">Tomography Geometry Matrices</a></li>
<li class="toctree-l1"><a class="reference internal" href="api_movement.html">Camera Movement Correction</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Examples</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#mapping-a-magnetic-field-line-on-to-an-image">Mapping a magnetic field line on to an image</a></li>
<li class="toctree-l2"><a class="reference internal" href="#rendering-camera-view-wireframe">Rendering: camera view wireframe</a></li>
<li class="toctree-l2"><a class="reference internal" href="#ray-casting">Ray casting</a></li>
<li class="toctree-l2"><a class="reference internal" href="#tomography-geometry-matrices">Tomography Geometry Matrices</a></li>
<li class="toctree-l2"><a class="reference internal" href="#camera-movement-correction">Camera Movement Correction</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="dev_fileformats.html">File Formats</a></li>
<li class="toctree-l1"><a class="reference internal" href="dev_imsources.html">Image Sources</a></li>
<li class="toctree-l1"><a class="reference internal" href="dev_coord_formatter.html">3D Coordinate Formatters</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Calcam</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a></li>
      <li class="breadcrumb-item active">Examples</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="examples">
<h1>Examples<a class="headerlink" href="#examples" title="Permalink to this heading"></a></h1>
<p>This page has some examples of using the Calcam API. It is not meant to demonstrate all API features exhaustively, but gives some examples of simple use cases and workflows; for more complete details of the API features please refer to the other API documentation pages.</p>
<section id="mapping-a-magnetic-field-line-on-to-an-image">
<h2>Mapping a magnetic field line on to an image<a class="headerlink" href="#mapping-a-magnetic-field-line-on-to-an-image" title="Permalink to this heading"></a></h2>
<p>We start with an image of a MAST plasma on to which we want to overlay a magnetic field line, which we will assume is saved as <code class="docutils literal notranslate"><span class="pre">image.png</span></code> in the current directory. We also have a Calcam calibration for that image stored in the file <code class="docutils literal notranslate"><span class="pre">mycalib.ccc</span></code>, which for convenience we assume is also saved in the current directory. Finally, we have a <code class="docutils literal notranslate"><span class="pre">.csv</span></code> file containing a set of 3D coordinates of points along a magnetic field line (generated using a field line tracing tool), with each row of the file containg X,Y,Z coordinates of a single point.</p>
<p>We can plot the field line on top of the image with the following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">calcam</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">cv2</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="c1"># Load the image using OpenCV</span>
<span class="n">cam_image</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="s1">&#39;image.png&#39;</span><span class="p">)</span>

<span class="c1"># Load the field line coordinates</span>
<span class="n">fieldline_3d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="s1">&#39;fieldline.csv&#39;</span><span class="p">,</span><span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>

<span class="c1"># Load the calcam calibration</span>
<span class="n">cam_calib</span> <span class="o">=</span> <span class="n">calcam</span><span class="o">.</span><span class="n">Calibration</span><span class="p">(</span><span class="s1">&#39;mycalib.ccc&#39;</span><span class="p">)</span>

<span class="c1"># Project the field line coordinates to image coordinates using calcam.</span>
<span class="c1"># Note: the [0] index here is because this is a single sub-view image and</span>
<span class="c1"># we want the image coordinates for sub-view #0.</span>
<span class="n">fieldline_2d</span> <span class="o">=</span> <span class="n">cam_calib</span><span class="o">.</span><span class="n">project_points</span><span class="p">(</span><span class="n">fieldline_3d</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

<span class="c1"># Plot the projected coordinates on the image.</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">cam_image</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">fieldline_2d</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">fieldline_2d</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>This results in the figure below:</p>
<img alt="MAST field line projection example" src="_images/mast_fieldline_example_1.png" />
<p>Note that the parts of the field line hidden behind the centre stack are still visible, which looks strange. To only show the parts of the field line which are not hidden behind parts of the machine, we can modify the above code to also load the MAST CAD model and check which points are hidden from the camera by the CAD geometry:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">calcam</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">cv2</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="c1"># Load the image using OpenCV</span>
<span class="n">cam_image</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="s1">&#39;image.png&#39;</span><span class="p">)</span>

<span class="c1"># Load the field line coordinates</span>
<span class="n">fieldline_3d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="s1">&#39;fieldline.csv&#39;</span><span class="p">,</span><span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>

<span class="c1"># Load the calcam calibration</span>
<span class="n">cam_calib</span> <span class="o">=</span> <span class="n">calcam</span><span class="o">.</span><span class="n">Calibration</span><span class="p">(</span><span class="s1">&#39;mycalib.ccc&#39;</span><span class="p">)</span>

<span class="c1"># Load the MAST CAD model</span>
<span class="n">mast_machine</span> <span class="o">=</span> <span class="n">calcam</span><span class="o">.</span><span class="n">CADModel</span><span class="p">(</span><span class="s1">&#39;MAST&#39;</span><span class="p">)</span>

<span class="c1"># Project the field line coordinates to image coordinates using calcam.</span>
<span class="c1"># This time, check for occlusion of the points by the CAD model.</span>
<span class="c1"># Note: the [0] index here is because this is a single sub-view image and</span>
<span class="c1"># we want the image coordinates for sub-view #0.</span>
<span class="n">fieldline_2d</span> <span class="o">=</span> <span class="n">cam_calib</span><span class="o">.</span><span class="n">project_points</span><span class="p">(</span><span class="n">fieldline_3d</span><span class="p">,</span><span class="n">check_occlusion_with</span><span class="o">=</span><span class="n">mast_machine</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

<span class="c1"># Plot the projected coordinates on the image.</span>
<span class="c1"># Occluded points now have np.nan in their coordinates, so MatPlotLib skips them</span>
<span class="c1"># and we see only the points not hidden behind bits of CAD model.</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">cam_image</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">fieldline_2d</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">fieldline_2d</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>Which results in the following figure:</p>
<img alt="MAST field line projection example" src="_images/mast_fieldline_example_2.png" />
</section>
<section id="rendering-camera-view-wireframe">
<h2>Rendering: camera view wireframe<a class="headerlink" href="#rendering-camera-view-wireframe" title="Permalink to this heading"></a></h2>
<p>For this example, we start with a Calcam calibration for a MAST camera, and we want to render a wireframe version of the MAST CAD model which aligns with the camera image. This might be used, for example, to use as an overlay on a plasma image to give context to the image. We can do this with the following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">calcam</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="c1"># Load the calcam calibration</span>
<span class="n">cam_calib</span> <span class="o">=</span> <span class="n">calcam</span><span class="o">.</span><span class="n">Calibration</span><span class="p">(</span><span class="s1">&#39;mycalib.ccc&#39;</span><span class="p">)</span>

<span class="c1"># Load the MAST CAD model and set it to be bright red wireframe</span>
<span class="n">mast_machine</span> <span class="o">=</span> <span class="n">calcam</span><span class="o">.</span><span class="n">CADModel</span><span class="p">(</span><span class="s1">&#39;MAST&#39;</span><span class="p">)</span>
<span class="n">mast_machine</span><span class="o">.</span><span class="n">set_wireframe</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">mast_machine</span><span class="o">.</span><span class="n">set_colour</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>

<span class="c1"># Render the image to produce the array rendered_im</span>
<span class="c1"># Also save as an image file &quot;wireframe.png&quot;</span>
<span class="n">rendered_im</span> <span class="o">=</span> <span class="n">calcam</span><span class="o">.</span><span class="n">render_cam_view</span><span class="p">(</span><span class="n">mast_machine</span><span class="p">,</span><span class="n">cam_calib</span><span class="p">,</span><span class="n">filename</span><span class="o">=</span><span class="s1">&#39;wireframe.png&#39;</span><span class="p">)</span>

<span class="c1"># Show the rendered image using matplotlib</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">rendered_im</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>This results in the following plot:</p>
<img alt="MAST wireframe example" src="_images/mast_wireframe_example.png" />
<p>and also the same image saved to the file <cite>wireframe.png</cite>.</p>
</section>
<section id="ray-casting">
<h2>Ray casting<a class="headerlink" href="#ray-casting" title="Permalink to this heading"></a></h2>
<p>Imagine we have an IR image from a first wall monitoring camera which shows some unusual event at pixel coordinates (100,250). We might want to get the 3D coordinates on the CAD model corresponding to this pixel to tell us where exactly this event took place. We could do this by ray-casting that particular pixel:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">calcam</span>

<span class="c1"># Load the calibration</span>
<span class="n">cam_calib</span> <span class="o">=</span> <span class="n">calcam</span><span class="o">.</span><span class="n">Calibration</span><span class="p">(</span><span class="s1">&#39;my_calibration.ccc&#39;</span><span class="p">)</span>

<span class="c1"># Load the CAD model</span>
<span class="n">jet_machine</span> <span class="o">=</span> <span class="n">calcam</span><span class="o">.</span><span class="n">CADModel</span><span class="p">(</span><span class="s1">&#39;JET&#39;</span><span class="p">)</span>

<span class="c1"># Do the ray cast to find the sight-line / CAD model intersection coordinates</span>
<span class="n">raydata</span> <span class="o">=</span> <span class="n">calcam</span><span class="o">.</span><span class="n">raycast_sightlines</span><span class="p">(</span><span class="n">cam_calib</span><span class="p">,</span><span class="n">jet_machine</span><span class="p">,</span><span class="n">x</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="mi">250</span><span class="p">)</span>

<span class="c1"># The coordinates at the wall are contained in the raydata&#39;s ray_end_coords array.</span>
<span class="n">coords</span> <span class="o">=</span> <span class="n">raydata</span><span class="o">.</span><span class="n">ray_end_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span>
</pre></div>
</div>
<p>The 3-element array <code class="docutils literal notranslate"><span class="pre">coords</span></code> will then contain the <span class="math notranslate nohighlight">\(X,Y,Z\)</span> coordinates, in metres, of where the event of interest appened.</p>
<p>Alternatively, we could ray cast every pixel on the detector and then find the coordinates from whiever one(s) we want afterwards:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Do the ray cast to find the sight-line / CAD model intersection coordinates</span>
<span class="n">raydata</span> <span class="o">=</span> <span class="n">calcam</span><span class="o">.</span><span class="n">raycast_sightlines</span><span class="p">(</span><span class="n">cam_calib</span><span class="p">,</span><span class="n">jet_machine</span><span class="p">)</span>

<span class="c1"># The coordinates at the wall are contained in the raydata&#39;s ray_end_coords array.</span>
<span class="n">coords</span> <span class="o">=</span> <span class="n">raydata</span><span class="o">.</span><span class="n">ray_end_coords</span><span class="p">[</span><span class="mi">250</span><span class="p">,</span><span class="mi">100</span><span class="p">,:]</span>

<span class="c1"># While we&#39;re at it, save the raydata in case we need it again later</span>
<span class="n">raydata</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;my_raydata.nc&#39;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="tomography-geometry-matrices">
<h2>Tomography Geometry Matrices<a class="headerlink" href="#tomography-geometry-matrices" title="Permalink to this heading"></a></h2>
<p>For this example, we assume we already have a set of saved raydata relating to a camera we want to tomographically invert. For the purposes of this example we imagine it is a divertor camera on MAST, which can see Z heights up to about -0.6m in its field of view. To make the geometry matrix, we do this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">calcam</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># Note that including &quot;if __name__ == &#39;__main__&#39; is actually important here;</span>
<span class="c1"># because the geometry matrix calculation uses multiprocessing, this</span>
<span class="c1"># python file will be imported in each child thread and if we omit this</span>
<span class="c1"># if statement, lots of bad things will happen.</span>
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
        <span class="c1"># Load the raydata (see previous example for how to generate raydata)</span>
        <span class="n">raydata</span> <span class="o">=</span> <span class="n">calcam</span><span class="o">.</span><span class="n">RayData</span><span class="p">(</span><span class="s1">&#39;my_raydata.nc&#39;</span><span class="p">)</span>

        <span class="c1"># Make a grid with 1cm grid cells in the poloidal plane on to which to invert.</span>
        <span class="c1"># This will use the wall contour from the &#39;MAST&#39; CAD model</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">calcam</span><span class="o">.</span><span class="n">gm</span><span class="o">.</span><span class="n">squaregrid</span><span class="p">(</span><span class="s1">&#39;MAST&#39;</span><span class="p">,</span><span class="n">cell_size</span><span class="o">=</span><span class="mf">1e-2</span><span class="p">,</span><span class="n">zmax</span><span class="o">=-</span><span class="mf">0.6</span><span class="p">)</span>

        <span class="c1"># We can plot the grid to check it looks OK:</span>
        <span class="n">grid</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="c1"># Now we have our grid and raydata, we can make a geometry matrix:</span>
        <span class="n">geom_mat</span> <span class="o">=</span> <span class="n">calcam</span><span class="o">.</span><span class="n">gm</span><span class="o">.</span><span class="n">GeometryMatrix</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span><span class="n">raydata</span><span class="p">)</span>

        <span class="c1"># We probably want to save it, so we can use it to invert any images from this camera.</span>
        <span class="n">geom_mat</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;my_geom_mat.npz&#39;</span><span class="p">)</span>

        <span class="c1"># If we want to use MATLAB to do the inversions, we can also save it in MATLAB format:</span>
        <span class="n">geom_mat</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;my_geom_mat.mat&#39;</span><span class="p">)</span>

        <span class="c1"># If we need to make the matrix smaller to make the inversion computation easier,</span>
        <span class="c1">#  we can tell it to bin the camera image, e.g. in 4x4 pixel blocks:</span>
        <span class="n">geom_mat</span><span class="o">.</span><span class="n">set_binning</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

        <span class="c1"># We could also inspect the number of sight-lines passing through each grid cell,</span>
        <span class="c1"># to get an idea of the camera&#39;s coverage of the reconstruction domain.</span>
        <span class="n">coverage</span> <span class="o">=</span> <span class="n">geom_mat</span><span class="o">.</span><span class="n">get_los_coverage</span><span class="p">()</span>
        <span class="n">geom_mat</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">coverage</span><span class="p">,</span><span class="n">cblabel</span><span class="o">=</span><span class="s1">&#39;Number of sight-lines&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>Now let’s imagine we have an image from the camera in a (height x width) NumPy array called <code class="docutils literal notranslate"><span class="pre">image</span></code>, which we want to invert. The actual solver for <span class="math notranslate nohighlight">\(Ax = b\)</span> to do the inversion is beyond the scope of Calcam, so let’s assume your sparse matrix solver of choice is a function with call signature <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">my_solver(A,b)</span></code>, where <code class="docutils literal notranslate"><span class="pre">x</span></code> will be a 1D vector containing the result, <code class="docutils literal notranslate"><span class="pre">A</span></code> is the geometry matrix and <code class="docutils literal notranslate"><span class="pre">b</span></code> is the input data vector. We would then do the tomographic inversion like so:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Re-format the camera image in to a 1D vector ready for inversion.</span>
<span class="c1"># Note: if we have binning or pixel exclusion set up in the geometry matrix,</span>
<span class="c1"># this takes care of all that for us (we just feed it the raw camera image).</span>
<span class="n">data_vec</span> <span class="o">=</span> <span class="n">geom_mat</span><span class="o">.</span><span class="n">format_image</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>

<span class="c1"># Call our sparse matrix solver of choice</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">my_solver</span><span class="p">(</span><span class="n">geom_mat</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">data_vec</span><span class="p">)</span>
</pre></div>
</div>
<p>We can then visualise the results and / or extract them for further analsys. Note that it is not straightforward to directly get the inversion results at a given <span class="math notranslate nohighlight">\(R,Z\)</span> position directly from <code class="docutils literal notranslate"><span class="pre">x</span></code>, since the order of veluaes in <code class="docutils literal notranslate"><span class="pre">x</span></code> corresponds to the order of the cell indexing in the grid, which can be arbitrary and depends on how the grid was constructued. We therefore need to use the grid’s <code class="xref py py-func docutils literal notranslate"><span class="pre">interpolate()</span></code> method to do this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Have a look at the results!</span>
<span class="n">geom_mat</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="c1"># Now let&#39;s say we want to get the inversion results</span>
<span class="c1"># along a slice at Z = -1.3m, for R from 0.3 -&gt; 1.2m</span>
<span class="n">r_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span><span class="mf">1.2</span><span class="p">,</span><span class="mi">90</span><span class="p">)</span>
<span class="n">z_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Rslice</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.3</span>

<span class="n">result_along_slice</span> <span class="o">=</span> <span class="n">geom_mat</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">r_coords</span><span class="p">,</span><span class="n">z_coords</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="camera-movement-correction">
<h2>Camera Movement Correction<a class="headerlink" href="#camera-movement-correction" title="Permalink to this heading"></a></h2>
<p>Let’s say we have a good calibration, and we have a <a class="reference internal" href="api_calib.html#calcam.Calibration" title="calcam.Calibration"><code class="xref py py-class docutils literal notranslate"><span class="pre">calcam.Calibration</span></code></a> object for it in <code class="docutils literal notranslate"><span class="pre">my_calib</span></code>. We also have an image from the same camera some time later when the camera has moved, stored in a Numpy array called <code class="docutils literal notranslate"><span class="pre">moved_im</span></code>. We can then try to determine the correction to align the moved image with the calibration by:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">mov</span> <span class="o">=</span> <span class="n">calcam</span><span class="o">.</span><span class="n">movement</span><span class="o">.</span><span class="n">detect_movement</span><span class="p">(</span><span class="n">my_calib</span><span class="p">,</span> <span class="n">moved_im</span><span class="p">)</span>
</pre></div>
</div>
<p>Alternatively, we can determine the camera movement manually using the GUI by:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">mov</span> <span class="o">=</span> <span class="n">calcam</span><span class="o">.</span><span class="n">movement</span><span class="o">.</span><span class="n">manual_movement</span><span class="p">(</span><span class="n">my_calib</span><span class="p">,</span> <span class="n">moved_im</span><span class="p">)</span>
</pre></div>
</div>
<p>Now we have a movement correction object, we can use it to warp the new image so it aligns with the calibration:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">corrected_image</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">mov</span><span class="o">.</span><span class="n">warp_moved_to_ref</span><span class="p">(</span><span class="n">moved_im</span><span class="p">)</span>
</pre></div>
</div>
<p>The array <code class="docutils literal notranslate"><span class="pre">corrected_image</span></code> then contains the image warped to align with the calibration, while <code class="docutils literal notranslate"><span class="pre">mask</span></code> is an array the same size as the image containing <code class="docutils literal notranslate"><span class="pre">True</span></code> where a pixel in the warped image contains real image data, and <code class="docutils literal notranslate"><span class="pre">False</span></code> if the corresponding pixel is outside the border of the actual data.</p>
<p>Alternatively, we could create an updated calibration object accounting for the camera movement:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">updated_calib</span> <span class="o">=</span> <span class="n">calcam</span><span class="o">.</span><span class="n">movement</span><span class="o">.</span><span class="n">update_calibration</span><span class="p">(</span><span class="n">my_calib</span><span class="p">,</span><span class="n">moved_im</span><span class="p">,</span><span class="n">mov</span><span class="p">)</span>
</pre></div>
</div>
<p>We can also save the movement correction for use again later, and load it back from a file:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">mov</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;my movement correction.cmc&#39;</span><span class="p">)</span>
<span class="n">mov_loaded</span> <span class="o">=</span> <span class="n">calcam</span><span class="o">.</span><span class="n">movement</span><span class="o">.</span><span class="n">MovementCorrection</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;my movement correction.cmc&#39;</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="api_movement.html" class="btn btn-neutral float-left" title="Camera Movement Correction" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="dev_fileformats.html" class="btn btn-neutral float-right" title="File Formats" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2015-2023, European Atomic Energy Community (EURATOM).</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>